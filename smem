#!/usr/bin/python
import re, os, sys, pwd, grp, optparse

def pids():
    '''get a list of processes'''
    return [int(e) for e in os.listdir("/proc") if e.isdigit()]

def pidmaps(pid):
    maps = {}
    start = None
    for l in file('/proc/%s/smaps' % pid):
    	f = l.split()
	if f[-1] == 'kB':
            maps[start][f[0][:-1].lower()] = int(f[1])
        else:
            start, end = f[0].split('-')
            start = int(start, 16)
            name = ""
            if len(f) > 5:
                name = f[5]
            maps[start] = dict(end=int(end, 16), mode=f[1],
                               offset=int(f[2], 16),
                               device=f[3], inode=f[4], name=name)

    return maps

def pidtotals(pid):
    maps = pidmaps(pid)
    t = dict(size=0, rss=0, pss=0, shared_clean=0, shared_dirty=0,
             private_clean=0, private_dirty=0, referenced=0, swap=0)
    for m in maps.iterkeys():
        for k in t:
            t[k] += maps[m].get(k, 0)
    t['maps'] = len(maps)
    return t

def processtotals(pids):
    totals = {}
    for pid in pids:
        try:
            totals[pid] = pidtotals(pid)
        except:
            continue
    return totals

def maptotals():
    t = dict(size=0, rss=0, pss=0, shared_clean=0, shared_dirty=0,
             private_clean=0, private_dirty=0, referenced=0, swap=0)

def sortmaps(totals, key):
    l = []
    for pid in totals:
        l.append((totals[pid][key], pid))
    l.sort()
    return [pid for pid,key in l]

def pidname(pid):
    l = file('/proc/%d/stat' % pid).read()
    return l[l.find('(') + 1: l.find(')')]

def pidname(pid):
    l = file('/proc/%d/stat' % pid).read()
    return l[l.find('(') + 1: l.find(')')]

def pidcmd(pid):
    c = file('/proc/%d/cmdline' % pid).read()[:-1]
    if not c:
        return pidname(pid)
    return c.replace('\0', ' ')

def piduser(pid):
    return os.stat('/proc/%d/cmdline' % pid).st_uid

def pidgroup(pid):
    return os.stat('/proc/%d/cmdline' % pid).st_gid

def memory():
    t = {}
    for l in file('/proc/meminfo'):
        m = _fieldpat.match(l)
        if m:
            t[m.group(1).lower()] = int(m.group(2))
    return t

def units(x):
    if x > 1024:
        x >>= 10
        if x > 1024:
            x >>= 10
            if x > 1024:
                x >>= 10
                return x + "G"
            return x + "M"
        return x + "K"
    return x

_ucache = {}
def username(uid):
    if uid not in _ucache:
        _ucache[uid] = pwd.getpwuid(uid)[0]
    return _ucache[uid]

_gcache = {}
def groupname(gid):
    if gid not in _gcache:
        _gcache[gid] = grp.getgrgid(gid)[0]
    return _gcache[gid]

def showpids():
    p = pids()
    pt = processtotals(p)

    def showuser(p):
        if options.numeric:
            return piduser(p)
        return username(piduser(p))

    def showsize(field):
        if numeric:
            return lambda n: pt[n][field]
        return lambda n: units(pt[n][field])

    fields = dict(
        pid=('PID', lambda n: n, '% 5s', lambda x: len(p)),
        uid=('UID', username, '%-5s', None),
        user=('User', showuser, '%-8s', None),
        name=('Name', pidname, '%-24.24s', None),
        command=('Command', pidcmd, '%-24.24s', None),
        swap=('Swap',lambda n: pt[n]['swap'], '% 8s', sum),
        uss=('USS', lambda n: pt[n]['private_clean']
             + pt[n]['private_dirty'], '% 8s', sum),
        rss=('RSS', lambda n: pt[n]['rss'], '% 8s', sum),
        pss=('PSS', lambda n: pt[n]['pss'], '% 8s', sum),
        )
    columns = options.columns or 'pid user command swap uss pss rss'

    showtable(p, fields, columns.split(), options.sort or 'pss')

def showtable(rows, fields, columns, sort):
    header = ""
    format = ""
    for n in columns:
        f = fields[n][2]
        format += f + " "
        header += f % fields[n][0] + " "

    l = []
    for n in rows:
        r = [fields[c][1](n) for c in columns]
        l.append((fields[sort][1](n), r))

    l.sort()

    if not options.no_header:
        print header

    for k,r in l:
        print format % tuple(r)

    if options.totals:
        # totals
        t = []
        for c in columns:
            f = fields[c][3]
            if f:
                t.append(f([fields[c][1](n) for n in rows]))
            else:
                t.append("")

        print "-" * len(header)
        print format % tuple(t)

# todo
#  fix disappearing dirs
#  show unknowns

# options
#  columns
#  numeric
#  sort order

parser = optparse.OptionParser("%prog [options]")
parser.add_option("-H", "--no-header", action="store_true",
    help="disable header line")
parser.add_option("-n", "--numeric", action="store_true",
    help="numeric output")
parser.add_option("-s", "--sort", type="str",
    help="field to sort on")
parser.add_option("-t", "--totals", action="store_true",
    help="show totals")
parser.add_option("-c", "--columns", type="str",
    help="columns to show")

defaults = {}
parser.set_defaults(**defaults)
(options, args) = parser.parse_args()

showpids()
